val debug : bool
type loc = { beg_pos : Lexing.position; end_pos : Lexing.position; }
val dummy_loc : loc
exception Report_toplevel of string * loc option
val min_pos : Lexing.position -> Lexing.position -> Lexing.position
val max_pos : Lexing.position -> Lexing.position -> Lexing.position
val loc_union : ?loc:loc -> loc -> loc -> loc
val loc_tighter : loc -> loc -> loc
type pat =
    Zero
  | One of loc
  | PVar of string * loc
  | PAnd of pat * pat * loc
  | PCons of string * pat list * loc
val pat_loc : pat -> loc
type expr =
    Var of string * loc
  | Num of int * loc
  | Cons of string * expr list * loc
  | App of expr * expr * loc
  | Lam of clause list * loc
  | ExLam of int * clause list * loc
  | Letrec of string * expr * expr * loc
  | Letin of pat * expr * expr * loc
and clause = pat * expr
val expr_loc : expr -> loc
val clause_loc : pat * expr -> loc
type sort = Num_sort | Type_sort | Undefined_sort
type var_name = sort * string
type typ =
    TVar of var_name
  | TCons of string * typ list
  | Fun of typ * typ
  | NCst of int
  | Nadd of typ list
  | TExCons of int
type atom = Eqty of typ * typ * loc | Leq of typ * typ * loc | CFalse of loc
type formula = atom list
type typ_scheme = var_name list * formula * typ
val extype_id : int ref
val extype_env : (int * typ_scheme) list ref
type struct_item =
    TypConstr of string * sort list
  | ValConstr of string * var_name list * formula * typ list * typ
  | PrimVal of string * typ_scheme
  | LetRecVal of string * expr * loc
  | LetVal of string * expr * loc
type program = struct_item list
val enc_funtype : typ -> typ list -> typ
val ty_add : typ -> typ -> typ
val typ_scheme_of_item :
  ?env:(string * typ_scheme) list -> struct_item -> typ_scheme
val current_file_name : string ref
val pr_loc_short : Format.formatter -> loc -> unit
val pr_loc_long : Format.formatter -> loc -> unit
val pr_loc_emb : Format.formatter -> loc -> unit
val pr_loc : Format.formatter -> loc -> unit
val pr_sep_list :
  string ->
  (Format.formatter -> 'a -> unit) ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a list -> unit
val pr_more_sep_list :
  string ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a list -> unit
val pr_pre_sep_list :
  string ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a list -> unit
val pr_line_list :
  string ->
  (Format.formatter -> 'a -> unit) ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a list -> unit
val pr_more_line_list :
  string ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a list -> unit
val pr_pat : bool -> Format.formatter -> pat -> unit
val pr_more_pat : bool -> Format.formatter -> pat -> unit
val pr_one_pat : Format.formatter -> pat -> unit
val collect_lambdas : pat list -> expr -> pat list * expr
val collect_apps : expr list -> expr -> expr list
val pr_tyvar : Format.formatter -> 'a * string -> unit
val pr_expr : bool -> Format.formatter -> expr -> unit
val pr_clause : Format.formatter -> clause -> unit
val pr_one_expr : Format.formatter -> expr -> unit
val collect_argtys : typ list -> typ -> typ list
val pr_atom : Format.formatter -> atom -> unit
val pr_formula : Format.formatter -> formula -> unit
val pr_ty : bool -> Format.formatter -> typ -> unit
val pr_one_ty : Format.formatter -> typ -> unit
val pr_fun_ty : Format.formatter -> typ -> unit
val pr_sort : Format.formatter -> sort -> unit
val pr_typscheme :
  Format.formatter -> ('a * string) list * formula * typ -> unit
val pr_struct_item : Format.formatter -> struct_item -> unit
val pr_program : Format.formatter -> struct_item list -> unit
