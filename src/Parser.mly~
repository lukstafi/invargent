/** YACC-type grammar for HMG Arith.

    Released under the GNU General Public Licence (version 2 or
    higher), NO WARRANTY of correctness etc. (C) Lukasz Stafiniak 2008
    @author Lukasz Stafiniak <lukstafi@gmail.com>
    @since May 2008
    @version 0.1
*/

%{
open Infer
;;
open Lexing
;;

let get_loc () =
  {beg_pos = symbol_start_pos (); end_pos = symbol_end_pos ()}
;;

let rhs_loc i = {beg_pos = rhs_start_pos i; end_pos = rhs_end_pos i}
;;

let unclosed opening_name opening_num closing_name closing_num =
  ignore (Format.flush_str_formatter ());
  Format.fprintf Format.str_formatter
    "@[<0>Syntax error:@ unclosed@ \"%s\"@ at@ %a:@ \"%s\" expected@ at@ %a@]"
    opening_name pr_loc (rhs_loc opening_num)
    closing_name pr_loc (rhs_loc closing_num);
  raise (Report_toplevel
	    (Format.flush_str_formatter (),
	    Some (rhs_loc closing_num)))

let syntax_error what where =
    raise (Report_toplevel ("Syntax error: "^what,
			   Some (rhs_loc where)))

let parse_error s =
  Format.printf
    "@[<2>%s@ %a@]@." s pr_loc (get_loc ())
    
%}

/* Ocamlyacc Declarations */
%token LPAREN RPAREN COMMA COLON EQUAL SEMICOLON AND
%token UNDERSCORE EXCLAMATION AMPERSAND
%token LET REC IN FOR ALL
%token <string> UIDENT
%token <string> LIDENT
%token <int> NUM
%token PLUS MULTIPLY MINUSGREATER BAR AS
%token FUNCTION FUN MATCH WITH
%token NAT TYPE
%token EQUALEQUALGREATER LESSEQUAL EQUALEQUAL
%token FALSE
%token NEWCONS NEWTYPE EXTERNAL MINUSMINUSGREATER
%token EOF

%nonassoc IN
%nonassoc LET AND
%nonassoc below_WITH
%nonassoc FUNCTION WITH
%right MINUSGREATER
%nonassoc AS
%nonassoc BAR
%right EQUALEQUALGREATER
%right BARBAR
%nonassoc below_AMPERSAND
%nonassoc AMPERSAND
%nonassoc below_COMMA
%nonassoc COMMA
%left PLUS
%nonassoc MULTIPLY
%nonassoc prec_constr_appl              /* above AS BAR COLONCOLON COMMA */
%nonassoc LPAREN

%start program
%type <Infer.struct_item list> program
%type <Infer.typ> simple_typ

/* Grammar follows */
%%
expr:
  | LET REC LIDENT EQUAL expr more_recdefs IN expr
      { Letrec (($3, $5) :: List.rev $6,
	       (* {beg_pos = rhs_start_pos 2; FIXME: body loc
		  end_pos = rhs_end_pos 5}, *) $8, get_loc ()) }
  | LET LIDENT EQUAL expr IN expr
      { App (Lam ([PVar ($2, rhs_loc 2), $6], rhs_loc 6), $4, get_loc ()) }
  | LET REC EQUAL expr IN expr
      { syntax_error "lacking let-binding identifier" 3 }
  | LET EQUAL expr IN expr
      { syntax_error "lacking let-rec-binding identifier" 2 }
  | LET REC LIDENT EQUAL expr error
      { unclosed "let" 1 "in" 6 }
  | LET LIDENT EQUAL expr error
      { unclosed "let" 1 "in" 5 }
  | FUNCTION opt_bar match_cases %prec below_WITH
      { Lam (List.rev $3, get_loc ()) }
  | FUNCTION error
      { syntax_error "function case branches expected" 2 }
  | FUN simple_pattern_list match_action
      { List.fold_right (fun p e -> Lam ([p, e], get_loc ()))
	  (List.rev $2) $3 }
  | MATCH expr WITH opt_bar match_cases %prec below_WITH
      { App (Lam (List.rev $5, {beg_pos = rhs_start_pos 3;
				end_pos = rhs_end_pos 5}), $2, get_loc ()) }
  | MATCH expr error
      { unclosed "match" 1 "with" 3 }
  | expr COMMA expr_comma_list %prec below_COMMA
      { Cons ("Tuple", ($1 :: List.rev $3), get_loc ()) }
  | simple_expr
      { $1 }
  | simple_expr_list
      { let loc = get_loc () in
	match List.rev $1 with
	  | [] | [_] -> assert false
	  | [f; a] ->
	      (match f, a with
		| Cons (x, [], _), Cons ("Tuple", args, _)
		    (* syntax... *)
		    (* when not (unary_constr loc cstrenv x) *) ->
		    Cons (x, args, loc)
		| Cons (x, [], _), _ -> Cons (x, [ a ], loc)
		| _ -> App(f, a, loc))
	  | f::args -> List.fold_left (fun f a ->
	      App (f, a, {beg_pos = symbol_start_pos ();
			  end_pos = (expr_loc a).end_pos})) f args }
;     
simple_expr:
  | LIDENT
      { Var ($1, get_loc ()) }
  | UIDENT
      { Cons ($1, [], get_loc ()) }
  | NUM
      { Num ($1, get_loc ()) }
  | LPAREN expr RPAREN
      { $2 }
  | LPAREN expr error
      { unclosed "(" 1 ")" 3 }
;
simple_expr_list:
  | simple_expr simple_expr
      { [ $2 ; $1 ] }
  | simple_expr_list simple_expr
      { $2 :: $1 }
;
expr_comma_list:
  | expr_comma_list COMMA expr
      { $3 :: $1 }
  | expr
      { [ $1 ] }
;
more_recdefs:
  | /* empty */
      { [] }
  | more_recdefs AND LIDENT EQUAL expr
      { ($3, $5)::$1 }

match_cases:
  |  pattern match_action
      { [$1, $2] }
  | match_cases BAR pattern match_action
      { ($3, $4) :: $1 }
;
match_action:
  | MINUSGREATER expr %prec below_WITH
      { $2 }
  | error
      { syntax_error "-> expected (function or match action)" 1 }
;

pattern:
  | simple_pattern
      { $1 }
  | UIDENT pattern %prec prec_constr_appl
      { match $2 with
	| PCons ("Tuple", args, _)
	    (* syntax... *)
	    (* when not (unary_type_constr (get_loc ()) $1) *) ->
	    PCons ($1, args, get_loc ())
	| _ -> PCons ($1, [ $2 ], get_loc ()) }
  | pattern AS pattern
      { PAnd ($1, $3, get_loc ()) }
  | pattern_comma_list  %prec below_COMMA
      { PCons ("Tuple", List.rev $1, get_loc ()) }
  | pattern BAR pattern
      { POr($1, $3, get_loc ()) }
;
pattern_comma_list:
  | pattern COMMA pattern
      { [ $3 ; $1 ] }
  | pattern_comma_list COMMA pattern
      { $3 :: $1 }
;

simple_pattern:
  LIDENT                                    { PVar ($1, get_loc ()) }
  | UNDERSCORE                              { One (get_loc ())}
  | EXCLAMATION                             { Zero }
  | UIDENT
      { PCons ($1, [], get_loc ()) }
  | LPAREN pattern RPAREN
      { $2 }
;
simple_pattern_list:
  | simple_pattern
      { [ $1 ] }
  | simple_pattern_list simple_pattern
      { $2 :: $1 }
;

typ:
  | simple_typ
      { $1 }
  | typ MINUSGREATER typ
      { Fun ($1, $3) }
  | typ_comma_list %prec below_COMMA
      { TCons ("Tuple", List.rev $1) }
  | UIDENT simple_typ
      { match $2 with
	| TCons ("Tuple", args)
	    (* syntax... *)
	    (* when not (unary_type_constr (get_loc ()) $1) *) ->
	    TCons ($1, args)
	| _ -> TCons ($1, [ $2 ]) }
;

typ_comma_list:
  | typ COMMA typ
      { [ $3 ; $1 ] }
  | typ_comma_list COMMA typ
      { $3 :: $1 }
;

simple_typ:
  | simple_typ PLUS simple_typ
      { ty_add $1 $3 }
  | LIDENT   { EVar (Undefined_sort, $1) }
  | UIDENT   { TCons ($1, []) }
  | NUM      { NCst $1 }
  | LPAREN typ RPAREN
      { $2 }
  | LPAREN typ error
      { unclosed "(" 1 ")" 3 }
;

sort:
  | NAT
      { Nat_sort }
  | TYPE
      { Type_sort }
;

formula:
  | formula_ampersand_list %prec below_AMPERSAND
      { List.rev $1 }
  | typ LESSEQUAL typ
      { [`Leq ($1, $3, get_loc ())] }
  | typ EQUALEQUAL typ
      { [`Eqty ($1, $3, get_loc ())] }
  | FALSE    { [`CFalse (get_loc ())] }
;

formula_ampersand_list:
  | formula AMPERSAND formula
      { $3 @ $1 }
  | formula_ampersand_list AMPERSAND formula
      { $3 @ $1 }
;

opt_constr_intro:
  | FOR ALL LPAREN lident_comma_list RPAREN COLON
      { List.rev $4, [] }
  | FOR ALL LPAREN lident_comma_list RPAREN error
      { unclosed "for all" 1 ": or with" 6 }
  | FOR ALL LPAREN lident_comma_list error
      { unclosed "(" 3 ")" 5 }
  | FOR ALL LPAREN lident_comma_list RPAREN WITH formula COLON
      { List.rev $4, $7 }
  | FOR ALL LPAREN lident_comma_list RPAREN WITH formula error
      { unclosed "for all" 1 ":" 8 }
  | WITH formula COLON
      { [], $2 }
  | WITH formula error
      { unclosed "with" 1 ":" 3 }
  | WITH error
      { syntax_error "formula expected" 2 }
  | FOR ALL LIDENT COLON
      { [ $3 ], [] }
  | FOR ALL LIDENT error
      { unclosed "for all" 1 ":" 4 }
  | FOR ALL LIDENT WITH formula COLON
      { [ $3 ], $5 }
  | FOR ALL LIDENT WITH formula error
      { unclosed "for all" 1 ":" 6 }
  | FOR error
      { syntax_error "<all> expected (two-word keyword <for all>)" 2 }
  | FOR ALL LPAREN error
      { syntax_error
	  "comma-separated list of lowercase identifiers expected" 4 }
  | FOR ALL error
      { syntax_error "<(> or lowercase identifier expected" 3 }
  | /* empty */
      { [], [] }
;

lident_comma_list:
  | LIDENT
      { [ $1 ] }
  | lident_comma_list COMMA LIDENT
      { $3 :: $1 }
;

structure_item:
  | NEWCONS UIDENT COLON opt_constr_intro typ_star_list MINUSMINUSGREATER typ
      { ValConstr ($2, (get_loc ()), (fst $4), (snd $4), $7,
	(List.rev $5)) }
  | NEWCONS UIDENT COLON opt_constr_intro typ_star_list error
      { unclosed "newcons" 1 "-->" 6 }
  | NEWCONS UIDENT COLON opt_constr_intro MINUSMINUSGREATER
      { syntax_error
	  "do not use --> for constructors without arguments" 5 }
  | NEWCONS UIDENT COLON opt_constr_intro typ
      { ValConstr ($2, (get_loc ()), (fst $4), (snd $4), $5,
	[]) }
  | NEWCONS UIDENT COLON opt_constr_intro typ_star_list MINUSMINUSGREATER error
      { syntax_error ("inside the constructor value type") 4 }
  | NEWCONS UIDENT COLON opt_constr_intro error
      { syntax_error ("inside the constructor type") 4 }
  | NEWCONS UIDENT COLON error
      { syntax_error ("<for all>, <with>,"^
	  " a star-separated list of types, or a type expected") 4 }
  | NEWCONS COLON
      { syntax_error
	  "lacking constructor identifier" 2 }
  | NEWCONS UIDENT error
      { unclosed "newcons" 1 ":" 3 }
  | NEWTYPE UIDENT COLON sort_star_list
      { TypConstr ($2, prepare_type_constr
	(List.rev $4)) }
  | NEWTYPE COLON
      { syntax_error
	  "lacking type identifier" 2 }
  | NEWTYPE UIDENT
      { TypConstr ($2, prepare_type_constr
	[] ) }
  | EXTERNAL LIDENT COLON opt_constr_intro typ
      { PrimVal ($2, (get_loc ()), (fst $4), (snd $4), $5) }
  | EXTERNAL COLON
      { syntax_error
	  "lacking external binding identifier" 2 }
  | LET REC LIDENT EQUAL expr more_recdefs
      { LetRecVal (($3, $5) :: List.rev $6, get_loc ()) }
  | LET REC LIDENT EQUAL error
      { syntax_error "error in the body of toplevel definition" 5 }
  | LET REC EQUAL
      { syntax_error
	  "lacking global let-rec-binding identifier" 3 }
  | LET LIDENT EQUAL expr
      { LetVal ($2, $4, get_loc ()) }
  | LET LIDENT EQUAL error
      { syntax_error "error in the body of toplevel definition" 4 }
  | LET EQUAL
      { syntax_error
	  "lacking global let-binding identifier" 3 }
;

typ_star_list:
  | typ
      { [ $1 ] }
  | typ_star_list MULTIPLY typ
      { $3 :: $1 }
;

sort_star_list:
  | sort           { [ $1 ] }
  | sort_star_list MULTIPLY sort
      { $3 :: $1 }
  | error
      { syntax_error "unrecognized sort" 1 }
;

opt_bar:
  | /* empty */      { () }
  | BAR              { () }
;

structure_item_list:
  | structure_item    { [ $1 ] }
  | structure_item_list structure_item { $2 :: $1 }
;

program:
  | EOF              { [] }
  | structure_item_list { List.rev $1 }
;

