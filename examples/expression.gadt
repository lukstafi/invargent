newtype Term : type * type
newtype Int
newtype EmptyEnv
newtype Brujin : type * type
newtype Env : type

newcons Pick : ∀a, b. Brujin (a, (a, b))
newcons Drop : ∀a, b, c. Brujin (c, b) ⟶ Brujin (c, (a, b))

newcons Cons : ∀a, b. a * Env b ⟶ Env (a, b)
newcons Empty : Env EmptyEnv

external plus : Int → Int → Int
external find : ∀a, b. Brujin (a, b) → Env b → a

newcons Const : ∀a. Int ⟶ Term (Int, a)
newcons Add : ∀a. Term (Int, a) * Term (Int, a) ⟶ Term (Int, a)

newcons Var : ∀a, b. Brujin (a, b) ⟶ Term (a, b)
newcons Abs : ∀a, b, c. Term (b, (a, c)) ⟶ Term ((a → b), c)
newcons App : ∀a, b, c)
  : Term (a, c) * Term ((a → b), c) ⟶ Term (b, c)

let rec eval = fun env -> function
  | Const i -> i
  | Add (x, y) -> plus (eval env x) (eval env y)
  | Var v -> find v env
  | Abs e -> (fun v -> eval (Cons (v, env)) e)
  | App (x, y) -> eval env y (eval env x)
