(*
** by: Dave Edelblute, edelblut@cod.nosc.mil, 05 Jan 1993
** Translated from C to de Caml: Hongwei Xi, 07 Nov 1998
** Modified: R. Mayer to work with hist benchmark routines.
** Translated to InvarGenT: Lukasz Stafiniak, 30 Jan 2015
*)
datatype Array : type * num
external let array_make :
  ∀n, a [0≤n]. Num n → a → Array (a, n) = "fun a b -> Array.make a b"
external let array_get :
  ∀n, k, a [0≤k ∧ k+1≤n]. Array (a, n) → Num k → a = "fun a b -> Array.get a b"
external let array_set :
  ∀n, k, a [0≤k ∧ k+1≤n]. Array (a, n) → Num k → a → () =
  "fun a b c -> Array.set a b c"
external let array_length :
  ∀n, a [0≤n]. Array (a, n) → Num n = "fun a -> Array.length a"

external let n2i : ∀n. Num n → Int = "fun i -> i"
external let div2 : ∀n. Num (2 n) → Num n = "fun i -> i / 2"
external let div4 : ∀n. Num (4 n) → Num n = "fun i -> i / 4"
external let n2f : ∀n. Num n → Float = "float_of_int"
external let equal : ∀a. a → a → Bool = "fun x y -> x = y"
external let leq : ∀a. a → a → Bool = "fun x y -> x <= y"
external let less : ∀a. a → a → Bool = "fun x y -> x < y"

external let abs : Float → Float = "abs_float"
external let cos : Float → Float = "cos"
external let sin : Float → Float = "sin"
external let neg : Float → Float = "(~-.)"
external let minus : Float → Float → Float = "(-.)"
external let plus : Float → Float → Float = "(+.)"
external let mult : Float → Float → Float = "( *. )"
external let div : Float → Float → Float = "( /. )"
external let fl0 : Float = "0.0"
external let fl0 : Float = "0.5"
external let fl1 : Float = "1.0"
external let fl2 : Float = "2.0"
external let fl3 : Float = "3.0"
external let fl4 : Float = "4.0"
external let pi : Float = "4.0 *. atan 1.0"
external let two_pi : Float = "8.0 *. atan 1.0"


let fft_part1 px py n = (* n must be a power of 2! *)
  assert num 2 <= n;
  let rec loop n2 n4 =
    if n2 <= 2 then () else (* the case n2 = 2 is treated below *)
    let e = div two_pi (n2f n2) in
    let e3 = mult fl3 e in
    let rec forbod j = 
    (*for j = 1 to n4 do*)
      (* lukstafi: this appears to be a placeholder? *)
      let a = fl0 in
      let a3 = fl0 in
      let cc1 = cos a in
      let ss1 = sin a in
      let cc3 = cos a3 in
      let ss3 = sin a3 in
      let a = plus a e in
      (* we know literally nothing about a, a3 *)
      (* so not carrying them through the loop is sound *)
      let a3 = plus a3 e3 in
      let rec loop1 i0 i1 i2 i3 id =
        if n + 1 <= i3 then () else (* out_of_bounds *)
        let g_px_i0 = array_get px i0 in
        let g_px_i2 = array_get px i2 in
        let r1 = minus g_px_i0 g_px_i2 in
        let r1' = plus g_px_i0 g_px_i2 in
        array_set px i0 r1';
        let g_px_i1 = array_get px i1 in
        let g_px_i3 = array_get px i3 in
        let r2 = minus g_px_i1 g_px_i3 in
        let r2' = plus g_px_i1 g_px_i3 in
        array_set px i1 r2';
        let g_py_i0 = array_get py i0 in
        let g_py_i2 = array_get py i2 in
        let s1 = minus g_py_i0 g_py_i2 in
        let s1' = plus g_py_i0 g_py_i2 in
        array_set py i0 s1';
        let g_py_i1 = array_get py i1 in
        let g_py_i3 = array_get py i3 in
        let s2 = minus g_py_i1 g_py_i3 in
        let s2' = plus g_py_i1 g_py_i3 in
        array_set py i1 s2';
        let s3 = minus r1 s2 in 
        let r1 = plus r1 s2 in
        let s2 = minus r2 s1 in
        let r2 = plus r2 s1 in
        array_set px i2 (minus (mult r1 cc1) (mult s2 ss1));
        array_set py i2 (minus (mult (neg s2) cc1) (mult r1 ss1));
        array_set px i3 (plus (mult s3 cc3) (mult r2 ss3));
        array_set py i3 (minus (mult r2 cc3) (mult s3 ss3));
        loop1 (i0 + id) (i1 + id) (i2 + id) (i3 + id) id in
      let rec loop2 is id =
        if n <= is then
          if j + 1 <= n4 then forbod (j + 1) else ()
        else (
          let i1 = is + n4 in
          let i2 = i1 + n4 in
          let i3 = i2 + n4 in
          loop1 is i1 i2 i3 id;
          loop2 (2 * id - n2 + j) (4 * id)) in
      loop2 j (2 * n2) in
    forbod 1; 
    loop (div2 n2) (div2 n4) in
  loop n (div4 n)
